# README

## Лекционное занятие №35

### Тема:

Репозитарий содержит материалы по занятию, посвященному работе с библиотекой `react-router`.

### Цели занятия
- повторение и закрепление знаний;
- решение задач.

### Зачем это нужно
Пока что, мы говорили об одностраничном приложении, т.е. Single Page Application. При такой ситуации, все компоненты рендерятся на одной странице, которая доступна по конкретному адресу. Но такого зачастую мало - нужно реализовать многостраничное приложение. То есть, чтобы приложение рендерило разные части на разных адресах - например, на главной странице рендерился бы перечень товаров, на странице корзины - корзина, была бы форма авторизации, и так далее. Просто средствами React, это реально, но проблематично, потому что фактически приложение все еще будет рисоваться на одном адресе. Поэтому, используются вспомогательные библиотеки, маршрутизаторы (роутеры), которые помогают имитировать многостраничность приложения. Одной из таких библиотек, наверное самой популярной, является react-router. О ней сегодня и поговорим.

В официальной документации, описывается два подхода: как фреймворк, и как библиотека. Мы рассмотрим второй подход, который поможет нам без особых сложностей добавить маршрутизацию в наше приложение.

### react-router
Зависимость уже добавлена в проект, поэтому можно сразу начинать работать.

**Добавление роутера в проект**
Добавление роутера в проект - очень несложная задача. Нужно "обернуть" наше приложение в провайдер роутера, и затем собственно указать, как будет работать маршрутизация. Дальше всю работу берет на себя библиотека.

```
import React from "react";
import ReactDOM from "react-dom/client";
import { BrowserRouter } from "react-router";
import App from "./app";

const root = document.getElementById("root");

ReactDOM.createRoot(root).render(
  <BrowserRouter>
    <App />
  </BrowserRouter>
);
```

Первым шагом мы оборачиваем наше приложение в провайдер роутера. Мы используем `BrowserRouter`, чаще всего используется именно эта обертка. Кроме нее, есть и другие варианты, например `HashRouter`, о них можно почитать на их официальном сайте.

**Создание маршрутов**
Созданием маршрутов ведают компоненты `Routes`, `Route` библиотеки `react-router`. Это компоненты-обертки, в которые мы оборачиваем наши компоненты. За счет этих оберток, библиотека будет сопоставлять фактический URL-адрес с путем, указанным в компоненте (`Route`), и в случае соответствия, компонент будет отрисован.

Попробуем разобрать на примере. Предположим, что в нашем приложении есть 3 страницы. Будем очень оригинальны, и сделаем для них компоненты `Page1`, `Page2`, `Page3` соответственно. И добавим в них какие-то параграфы и заголовки с содержимым. Это все создано в папке `src/pages`.

Если мы просто отрендерим их в компоненте `App`, то они так и будут рисоваться один под другим, вне зависимости от адреса страницы. А давайте поставим задачу: нужно чтобы эти страницы рендерились в зависимости от адреса. То есть, если адрес в строке браузера будет `localhost:3000/page1` - то рендерим только первую страницу. Если `localhost:3000/page2` - только вторую, и т.д. Реализовать это имеющимися у нас средствами возможно, но довольно проблематично. Воспользуемся библиотекой `react-router`.

```
import './App.css';
import { Routes, Route } from "react-router";
import Page1 from './pages/Page1';
import Page2 from './pages/Page2';
import Page3 from './pages/Page3';

function App() {

  return (
    <div className="App">
      <Routes>
        <Route path="/page1" element={<Page1 />} />
        <Route path="/page2" element={<Page2 />} />
        <Route path="/page3" element={<Page3 />} />
      </Routes>
    </div>
  );
}
```

И теперь, если мы введем в адресной строке `localhost:3000/page1` - то мы окажемся на первой странице нашего приложения. При этом, вторая и третья отрисованы не будут. То есть, рисуется только тот маршрут (роут), чей проп `path` соответствует фактическому адресу страницы. Путь /page1 - это значит "корневой адрес сервиса, плюс /page1".

**Маршрут по умолчанию**



### Полезные ссылки
[Использование рефов](https://react.dev/learn/referencing-values-with-refs#) - работа с рефами как с хранилищем.
[Императивная работа с DOM](https://react.dev/learn/manipulating-the-dom-with-refs) - работа с DOM напрямую.
[Хук useRef](https://react.dev/reference/react/useRef) - информативно, с интерактивными примерами.
[Библиотека react-hook-form](https://www.react-hook-form.com/get-started/) - официальная документация проекта. Очень информативная, и с примерами.